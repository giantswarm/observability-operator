import logging
from typing import List

import pykube
import pytest

from pytest_helm_charts.clusters import Cluster
from pytest_helm_charts.k8s.deployment import wait_for_deployments_to_run
from pytest_helm_charts.giantswarm_app_platform.app import (
    wait_for_apps_to_run,
    AppFactoryFunc,
    AppCR,
)
from pytest_helm_charts.utils import YamlDict

logger = logging.getLogger(__name__)

namespace_name = "monitoring"
deployment_name = "observability-operator"
timeout: int = 560


@pytest.mark.smoke
def test_api_working(kube_cluster: Cluster) -> None:
    """
    Testing apiserver availability.
    """
    assert kube_cluster.kube_client is not None
    assert len(pykube.Node.objects(kube_cluster.kube_client)) >= 1

@pytest.fixture(scope="module")
def deployments(kube_cluster: Cluster) -> List[pykube.Deployment]:
    logger.info("create mandatory secrets for deployment")
    grafanaSecret = {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
        "name": "grafana",
        "namespace": "monitoring"
    },
    "type": "Opaque",
    "data": {
        "admin-password": "YWRtaW4=",
        "admin-user": "YWRtaW4=",
      },
    }

    pykube.Secret(kube_cluster.kube_client, grafanaSecret).create()

    # This is a dummy openssl generated x509 certificate.
    grafanaTLSSecret = {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
        "name": "grafana-tls",
        "namespace": "monitoring"
    },
    "type": "Opaque",
    "data": {
        "tls.crt": "LS0tLS1CRUdJTkNFUlRJRklDQVRFLS0tLS1NSUlGWlRDQ0EwMmdBd0lCQWdJVUhEQTcrdnowVU84WjVDcEhtVXZlbXBWa21CMHdEUVlKS29aSWh2Y05BUUVMQlFBd1FqRUxNQWtHQTFVRUJoTUNXRmd4RlRBVEJnTlZCQWNNREVSbFptRjFiSFFnUTJsMGVURWNNQm9HQTFVRUNnd1RSR1ZtWVhWc2RDQkRiMjF3WVc1NUlFeDBaREFlRncweU5ERXhNRFF4TVRJME1UbGFGdzB5TlRFeE1EUXhNVEkwTVRsYU1FSXhDekFKQmdOVkJBWVRBbGhZTVJVd0V3WURWUVFIREF4RVpXWmhkV3gwSUVOcGRIa3hIREFhQmdOVkJBb01FMFJsWm1GMWJIUWdRMjl0Y0dGdWVTQk1kR1F3Z2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQ0R3QXdnZ0lLQW9JQ0FRQ1c0VUVpWEF3RmlpUkhwTTJ0VXNuMVNKdkh3VEdyaW5ScWFXdUZ5dzRoZmNTN0lBY290RDRkN28xbmJZb0lsLzJJU0FsVFpZc2FrQzVtM1hobnI1bmNzV0krTnpwLzFXOGJISFNVeVVXdVp6c29nSlZ4cXU2SWhzL05ZU2FDU2xyOTd5Rkd4YXBya0t4NWgwZ2ZEN2lIOFpENng5Y3RlRnlrTHVEdFViTG1CcWNkVEtkZ3ZFTVNSMG02bGNvYzlmREdRWStRcml1UktLNmJBRjNxdU4zTjNHUjNLOUpZS252MDRwQzh5RkkrY0tMVlpFT0JVc2k3ejlaSWxoRWR5ekFvTVhEQ3lwTWVqcVQwUlpiVnlLRnl3L2FhM2FYZldkUnZhdzVNUlBONXE3WmZjbEFGMWN6UjVON0I4UWFNUnlZVzJKakpwYUh1RkFBTitxMlRBdlZSRENNdXJYQVFsNEsyOWpQTkdxdU4vM0NLczNOemhqV2V5VFRhZnVMcEZ6ZklMZlpWd050RWZaV0VzbWVRMlZtWHNxTVI4bXhldHRnS2xoTVZoakpvbktLL1hjOElJK3l0c0h5Q1B3ZWxiSHdOVVVyU0o3aUNjWXJLSURWRWdWRkMyRkFxWlkyd24rYUpZOHNDRTZYaGNWZWFzWGp5SGpHTEs2K0ZqcUFOUVpkTFBWbzkzZVZoQThlTWJ2UlFiR0dqS2ZYMWN3Z1dOWnhkT0JYUngwYjZjRm1STUMyWXhtb1JoWFJxOVUvdGE1eTRndjYyZEN0ZUViR3Z3VnZxWFVUS3dBNEFaclZPdGJvKzEyczBaMVk0NWlQaTJPSktITkhFWnVhRlQxNG9vZHJWd1ZZcFAzR24yYmJ2aUpWcE9jNldCTFpFSjZKQjhGYUxqZzArN1RDVFFRSURBUUFCbzFNd1VUQWRCZ05WSFE0RUZnUVVQWng1SFdQNVErTlpjeGFDNU40NG1COGROU0V3SHdZRFZSMGpCQmd3Rm9BVVBaeDVIV1A1UStOWmN4YUM1TjQ0bUI4ZE5TRXdEd1lEVlIwVEFRSC9CQVV3QXdFQi96QU5CZ2txaGtpRzl3MEJBUXNGQUFPQ0FnRUFYSkZnL0RuOFcwa0I4cWMxaUx4M0g0cThDa1pBUDZNRkVFWFN0dXQwSDZhcUhVRUdiK1VGTmUweXZ6N3JRSThYdmpsYS94SmQwSm5YUXg4OXVQOERQM2I5WnFJSmR3VVlqREhOQjZoRUZRVUUxb1ZxbEc2WkF0RGdZQkJ3anZDR0xyQXFneHFpMjE5THNtMmIxTVlLUnRBQVBSSGI3WSsvTWlFMFBTaExzaEFpMFFJdW9TVE1kZXZUZHB6Zk5ESXJUTDRjUG0ydEwyR1VxVm1aOW95M01CdlUybk9MS2RxRWk4Zjdva3o0cjZudEtzY2RibGRLZEJ4V2VFTmxnQUYwUjQ0dmxVanExMVV2RnRiQ09sMnlod2drY29UNmx1RlpLN2ZVblVYaEFzdWp1WlRVVlBBWkVIamtFcjZDSDI2blVuemFycHI5SVJnZ1hManJHdTk2MTR2T1JaZFR3QngxWmdmMXZTOWl2WUdheVBCZ0d2UzNwWHhWYzRab0dnQ1FGUmZWVUV1YmRzY1E3MVBwLytMRzRJdVkxWUxjVGVhSCs2ZHJhWTlicUloVmNtcEUvZXVJeTh6MzRoSlY2M3o4aXBYeFlnY09qblJBcmRtRE40ZlJXY2haZFZiZGV2UENMSjFLTmpmZ01mbkNVWEkya3FBcE9QNVpFRHFHc3JBUUo0dHNkamxWQXRRdVNLc0JmSFp5YUtwb2ZXMCtab0Y2TTZKMlY2dXIxSTlPWTJHU1E0bDdmZG92d2NFUTBpRE11T0VhWmhsUW5la3RoazNlZERHZVQyTUlpb2pJdWN1VW1ScVlOemU4ZkRFU1RUUUEwU2pkWGd6bFJwZ0ZQb2lLNFFvbTJBRzNSeThtS2MwQTRzTHlUMmwxbW1SZFFYcmpXZHRUZFh6WGpoND0tLS0tLUVORENFUlRJRklDQVRFLS0tLS0=",
        "tls.key": "LS0tLS1CRUdJTlBSSVZBVEVLRVktLS0tLU1JSUpRZ0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQ1N3d2dna29BZ0VBQW9JQ0FRQ1c0VUVpWEF3RmlpUkhwTTJ0VXNuMVNKdkh3VEdyaW5ScWFXdUZ5dzRoZmNTN0lBY290RDRkN28xbmJZb0lsLzJJU0FsVFpZc2FrQzVtM1hobnI1bmNzV0krTnpwLzFXOGJISFNVeVVXdVp6c29nSlZ4cXU2SWhzL05ZU2FDU2xyOTd5Rkd4YXBya0t4NWgwZ2ZEN2lIOFpENng5Y3RlRnlrTHVEdFViTG1CcWNkVEtkZ3ZFTVNSMG02bGNvYzlmREdRWStRcml1UktLNmJBRjNxdU4zTjNHUjNLOUpZS252MDRwQzh5RkkrY0tMVlpFT0JVc2k3ejlaSWxoRWR5ekFvTVhEQ3lwTWVqcVQwUlpiVnlLRnl3L2FhM2FYZldkUnZhdzVNUlBONXE3WmZjbEFGMWN6UjVON0I4UWFNUnlZVzJKakpwYUh1RkFBTitxMlRBdlZSRENNdXJYQVFsNEsyOWpQTkdxdU4vM0NLczNOemhqV2V5VFRhZnVMcEZ6ZklMZlpWd050RWZaV0VzbWVRMlZtWHNxTVI4bXhldHRnS2xoTVZoakpvbktLL1hjOElJK3l0c0h5Q1B3ZWxiSHdOVVVyU0o3aUNjWXJLSURWRWdWRkMyRkFxWlkyd24rYUpZOHNDRTZYaGNWZWFzWGp5SGpHTEs2K0ZqcUFOUVpkTFBWbzkzZVZoQThlTWJ2UlFiR0dqS2ZYMWN3Z1dOWnhkT0JYUngwYjZjRm1STUMyWXhtb1JoWFJxOVUvdGE1eTRndjYyZEN0ZUViR3Z3VnZxWFVUS3dBNEFaclZPdGJvKzEyczBaMVk0NWlQaTJPSktITkhFWnVhRlQxNG9vZHJWd1ZZcFAzR24yYmJ2aUpWcE9jNldCTFpFSjZKQjhGYUxqZzArN1RDVFFRSURBUUFCQW9JQ0FBT2MxU0JyZkpsbTlQYWdseXFMcHV5d0wvcXlkRkpvWHEwNHkxNnZpbUVUdGo2V1g3dm9rYmo4ODBOcGhHM0pERVNnUzFXcmRmV2FFSldRV01leXlFZnhzcEFhQUFndXY3Tis0Ym9mNHMramJTTExoOGlEdzZURk9NaUtoMXhScmR0RjRWR3hzU0tIemtZMTIyeWZ4YjFZV2k1VDAyNis0cUtUd1pMNTZ3TVMrYlNWZmE0VlJ4cW1JeC9NTHlwT1d0VWVBL014c2dQQnc1eURUSWt1b3pEejN5OG1mM1p5a1NyWkdlMUxRRFo2aGxoazRQMjA2N3ZwNU56TUVYYy85ZFJ0VjIxeWxSSnAxWTFJanVCcDgyT3RTWVJTOWs3NzluSE1nNTY2U1lWWEZUUUJkRXQxMzNlYjZ1UzNnZVVIa0xDMXY4TEtyQldDRDN5c21lZGExTWMvQUhOVWdjYnBOb3VCSG5SOXYrc1JpQ2krTDJJREQ2T05VOXpyb00reHk5U1k0V2xBWEozcmFjRWJwZjl3cHFXNURtaEoxWW5ldGFBamUwb1c4cHQ5VWlVbHpjeFl5bW5NK0tNM3V3NW43RGU4dGpLeDlBRlc1QlN4VjdqOXZSOGRyZ2N1VmlxY0s1R2gvekFkanFRK1dqOVJHSjUyNHFyZzhQSHRWeXREMlVrN3AvL01rZjVKNHFzWWtNRml3Z0U1U2g4bEZ2VWdCOENGY3ZmMFdXY1RhUXFmYjFzcEZubTQwcHp3cUF0NFYxdFFvQ2d4c2ZnT3FSUzJqOE1xbXVVOVIwVTZ6NDVFU0l0MkpsZ3plbXFvQ0oyMjZacTJMc3lBOEdGVjhNOHRiSkg1cHU5TW40QTR0WngwWHpscHZNTnhtNEFIKzRTWG1PUWVQaE1rRzlJNUFvSUJBUURLRVZoVWw1dzdpRmh1YkxhVkNaRVJoV0dROFkxaHNJeGNKekFyQU1iYWE5Z3M0NW1jTU94aEhWRDQ0YmlSUEFBY2RlWFhCMXhIbVVmV3ZJV2g0QVY1a2xGMWdzRUZML1pDN2pjT1VtQ1RXSFk3WkpVdkk1UnJKeDBCa2JHbjFSQ0Mrajl4SW1IdFlkUlZ5bm1JWUY0U2k5czY1cUFxbzBON1BDVDJJdmlmUnRzLytMRlQzYnlYSmNYTVRrZGdyVHFwVy9SdktuWDBtQjBnVXlxWVlwL3FPbDdyK1N4dmppSDVMUS9HV0Jmd3NZV2pxSThuY1Q2RytMd085MTZBNE56ZXAvUnM2S0VVNlprMHJlQm5lOWxabzZoM0Vvd1pIUE5VVEVnTS9oOVVYNHhpTlZIRTVFMlk5TkYzb2s4Y0l3R3lxZVphcHFGUkZXY2RZdXBsVmdVM0FvSUJBUUMvSm1kemZEWkZDQVZ4L1I1UndLZkxaTURkVUxxY0Q1TjV2a1g3UG5PRFNSbVdQMWxBZkd4VjhydkFNYjl4bXJGSDJRaVJlS0ozcmlVclBCS2dhQzAvUDh0TUhibStqbHA1R1pXM3p4YU5aOFhyR2hWRlJpYUZhRDh4R3B5WWFBWUdNR0swbzh1YnBrZnpzMUVtaGVObFRvS09SU0RrOHhMMStpOTU5elRtZTNYbnBUNUU5Um1VTjRKZk1xdWM3eE9Xc3g4NkU3QTJDbjEvcW9wU0dzNUpTTEdpVHNFNi9TWklLWEU2amJUcmFvRWVFWkRvaUQ0Y0R0MnkxbFVORDdWNGc1Y1d0ZHZLWVo5amFFNnRaaUZKUm5QQkFEbEF2RVpBRW9iaGs1b2lJSnorWnBOc1pEdmY0VkRXbVFTdmZTOXdieWh3dUE4TXBKTHQvYktacEdkSEFvSUJBUUNaVktRVVBKOCt4VzFsRFhWV2psWFlWNy83UG5Bc0NzM1hONTFqWkVtQWdJa2ZOdTNmQ1hpMUVJdmE3MTBnUjhsRnoyakN6RUVIeTVZcHFoQTFEMHJZUDJFMHJDMVBoRjkzMWs5TXZOR3Z2VmFxSnQ3VlVFaFZMdTdodSs1MURrWmpQUVZiRWQ0QlJWVGNiTEhmL0ZBbC9wNHlpY0pMMkd0aVhmY21GczlWL1d4dGxJYnF2cjFXYkVFMWtNaTA0WDQ3K1J6NEpkNHY1aVZqMi9mY2Zpb2VrSUJxeXo4ZXYxbWtQTDlWb0k4NkExc0hIdWJSNVNxdlBKdG5OK29zSFhVOE4zSlFHZzN4VW5rQThsZnY3cGkxWG14OVBrTzA0clQ1NkpCYjI1Rm1jc0tSMnlmYkllcUlBRzNhTy8yUHVqaVZuRHJCMnVOYUpjV0RGUVlNTTBQdEFvSUJBQjNwRllFRnE3eExrQWFSTkFCWTVDaTRnRkZoUTRJT0VlYVg5bjFrL1ZCS3pQMHN0bnVYdktBS1ZvU3hoQ0p6c1Uvcnp5SnNQUWY3TVFlOTQ3QkQvT2lMdy9VS0pibUNydmVLSUZwZHhrcWtOVjBmZkxxVlNvdlBqeXZRM1RZZitPbFpBdWovUkduN3NBQ2JTNVI2bU9XT1RuR1NzWjRCeHpMRVRrK0lkamVtbEFHR1l1TUpjMUkxQ1dwNkZFNS9QcEp6UHV5b2pnYzJ4d0tHSGhUUTZ2eWVxbVVhYTdRZVRySTJBZWpHcWN1NG83R2YwQXdDM2Ewb1NscWtuVFJwQTkxeXdkNms0RnFmd2dBZEgwcVUwNXFTc3FROXM3ZkVmajJpYUlhOXdQMmNHdFRZR2pONHo4R3RrU2V6VS85ZDJHR0FrMVJvQ0xyU3VjY1J6ck9wL1JzQ2dnRUFMWnA0blZhTTd0ak9uVnVFejVhUkJvU3IrK0wyL1ZxSzU4MDlPOGUrTStGalZFSmhmQVVPKzFjdVRBSkZLUmNtWkJpRStIN1hxMlZyMFpzdzArYUJ0TWdXbGNFRlRIZFVKQVU4WUtPWmNYL0NGTEtRYU5KKzVEVlk0aGZLWFhETFhOdlhTSTlER21nalNzdE5zV1dpdk1PcjBhMGNZbXpOZk9kSTFGU1c0WWJrc1A1a2F4MmRWQU9yREs2RUtHZ2doRXpDcCswMzZPK1FDaDZQQVJ2cVFWSytYUnB2U2xaUTVMTm1MbkdiaXh6bjZVaWJkZmhEMVpGaG1RTTlabWp4UXgrK0NnM1BPRWJyQVRNYXdNNnRTVVF0UnZKb21hQmpRbFcyNjdGSUhyQ2EwRTRpdnVXNnVVand4cmMrWERXL2Vqb3lqQjhxcm8rVThienNjL1lTWFE9PS0tLS0tRU5EUFJJVkFURUtFWS0tLS0t",
      },
    }
    pykube.Secret(kube_cluster.kube_client, grafanaTLSSecret).create()

    logger.info("waiting for observability-operator deployment")
    deployment_ready = wait_for_deployments_to_run(
        kube_cluster.kube_client,
        [deployment_name],
        namespace_name,
        timeout,
    )
    logger.info("observability-operator deployment is ready")

    return deployment_ready


@pytest.fixture(scope="module")
def pods(kube_cluster: Cluster, deployments: List[pykube.Deployment]) -> List[pykube.Pod]:
    pods = pykube.Pod.objects(kube_cluster.kube_client)

    pods = pods.filter(
        namespace=namespace_name,
        selector={
            "app.kubernetes.io/name": "observability-operator",
            "app.kubernetes.io/instance": "observability-operator",
        },
    )

    return pods


# when we start the tests on circleci, we have to wait for pods to be available, hence
# this additional delay and retries
@pytest.mark.smoke
@pytest.mark.upgrade
@pytest.mark.flaky(reruns=5, reruns_delay=10)
def test_pods_available(deployment: List[pykube.Deployment]):
    for s in deployment:
        assert int(s.obj["status"]["readyReplicas"]) == int(s.obj["spec"]["replicas"])
