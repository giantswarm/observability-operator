# This file was generated by observability-operator.
# It configures Alloy instance used to load alerting and recording rules into the Mimir and Loki rulers.
networkPolicy:
  cilium:
    egress:
    - toEntities:
      - kube-apiserver
      - world
    - toEndpoints:
      - matchLabels:
          io.kubernetes.pod.namespace: kube-system
          k8s-app: coredns
      - matchLabels:
          io.kubernetes.pod.namespace: kube-system
          k8s-app: k8s-dns-node-cache
      toPorts:
      - ports:
        - port: "1053"
          protocol: UDP
        - port: "1053"
          protocol: TCP
        - port: "53"
          protocol: UDP
        - port: "53"
          protocol: TCP
    - toEndpoints:
      - matchLabels:
          app.kubernetes.io/component: ruler
          app.kubernetes.io/name: mimir
          io.kubernetes.pod.namespace: mimir
      toPorts:
      - ports:
        - port: "8080"
          protocol: TCP
    - toEndpoints:
      - matchLabels:
          app.kubernetes.io/component: backend
          app.kubernetes.io/name: loki
          io.kubernetes.pod.namespace: loki
      toPorts:
      - ports:
        - port: "3100"
          protocol: TCP
alloy:
  alloy:
    configMap:
      content: |
        // load rules for tenant giantswarm
        mimir.rules.kubernetes "giantswarm" {
          address = "http://mimir-ruler.mimir.svc:8080/"
          tenant_id = "giantswarm"
          rule_selector {
            // We use a non existing label to make sure this alloy instance does not match with any Prometheus Rules crs
            // This will make sure that the existing alerts loaded under the alloy namespace are now deleted as they are loaded by another alloy.
            match_expression {
              key = "nonexisting"
              operator = "In"
              values = ["nonexistant"]
            }
          }
        }
        loki.rules.kubernetes "giantswarm" {
          address = "http://loki-backend.loki.svc:3100/"
          tenant_id = "giantswarm"
          rule_selector {
            // We use a non existing label to make sure this alloy instance does not match with any Prometheus Rules crs
            // This will make sure that the existing alerts loaded under the alloy namespace are now deleted as they are loaded by another alloy.
            match_expression {
              key = "nonexisting"
              operator = "In"
              values = ["nonexistant"]
            }
          }
        }
  controller:
    type: "deployment"
    replicas: 1
  crds:
    create: false
verticalPodAutoscaler:
  enabled: true
